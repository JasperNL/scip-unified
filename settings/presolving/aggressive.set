# maximal number of presolving rounds (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
presolving/maxrounds = -1

# abort presolve, if at most this fraction of the problem was changed in last presolve round
# [type: real, range: [0,1], default: 0.0001]
presolving/abortfac = 0.0001

# maximal number of restarts (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
presolving/maxrestarts = -1

# fraction of integer variables that were fixed in the root node triggering a restart with preprocessing after root node evaluation
# [type: real, range: [0,1], default: 0.05]
presolving/restartfac = 0.03

# fraction of integer variables that were fixed in the root node triggering an immediate restart with preprocessing
# [type: real, range: [0,1], default: 0.2]
presolving/immrestartfac = 0.2

# fraction of integer variables that were globally fixed during the solving process triggering a restart with preprocessing
# [type: real, range: [0,1], default: 1]
presolving/subrestartfac = 1

# minimal fraction of integer variables removed after restart to allow for an additional restart
# [type: real, range: [0,1], default: 0.1]
presolving/restartminred = 0.06

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/linear/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/delaypresol = FALSE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/presolusehashing = TRUE

# should presolving search for aggregations in equations
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/aggregatevariables = TRUE

# should presolving try to simplify inequalities
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/simplifyinequalities = TRUE

# should dual presolving steps be preformed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/dualpresolving = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/and/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/delaypresol = FALSE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/presolpairwise = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/bounddisjunction/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bounddisjunction/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/conjunction/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/conjunction/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
constraints/countsols/maxprerounds = 0

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/indicator/maxprerounds = -1

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/delaypresol = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/integral/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/knapsack/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/delaypresol = FALSE

# enable linear upgrading for constraint handler <knapsack>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/knapsack = TRUE

# should disaggregation of knapsack constraints be allowed in preprocessing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/disaggregation = TRUE

# should presolving try to simplify knapsacks
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/simplifyinequalities = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/logicor/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/delaypresol = FALSE

# enable linear upgrading for constraint handler <logicor>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/logicor = TRUE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/logicor/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/logicor/presolusehashing = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/or/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/or/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/quadratic/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/delaypresol = FALSE

# whether a square of a binary variables should be replaced by the binary variable
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/replacesqrbinary = TRUE

# max. length of linear term which when multiplied with a binary variables is replaced by an auxiliary variable and a linear reformulation (0 to turn off)
# [type: int, range: [0,2147483647], default: 2147483647]
constraints/quadratic/replacebinaryprod = 2147483647

# whether quadratic constraints consisting of several quadratic blocks should be disaggregated in several constraints
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/disaggregate = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/setppc/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/setppc/delaypresol = FALSE

# enable linear upgrading for constraint handler <setppc>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/setppc = TRUE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/setppc/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/setppc/presolusehashing = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/SOS1/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/SOS2/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS2/delaypresol = FALSE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/varbound/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/varbound/delaypresol = FALSE

# enable linear upgrading for constraint handler <varbound>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/varbound = TRUE

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/xor/maxprerounds = -1

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/xor/delaypresol = FALSE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/xor/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/xor/presolusehashing = TRUE

# priority of presolver <boundshift>
# [type: int, range: [-536870912,536870911], default: 7900000]
presolving/boundshift/priority = 7900000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
presolving/boundshift/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/boundshift/delay = FALSE

# absolute value of maximum shift
# [type: longint, range: [0,9223372036854775807], default: 9223372036854775807]
presolving/boundshift/maxshift = 9223372036854775807

# is flipping allowed (multiplying with -1)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
presolving/boundshift/flipping = TRUE

# shift only integer ranges?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
presolving/boundshift/integer = TRUE

# priority of presolver <dualfix>
# [type: int, range: [-536870912,536870911], default: 8000000]
presolving/dualfix/priority = 8000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/dualfix/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/dualfix/delay = FALSE

# priority of presolver <implics>
# [type: int, range: [-536870912,536870911], default: -10000]
presolving/implics/priority = -10000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/implics/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/implics/delay = FALSE

# priority of presolver <inttobinary>
# [type: int, range: [-536870912,536870911], default: 7000000]
presolving/inttobinary/priority = 7000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/inttobinary/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/inttobinary/delay = FALSE

# priority of presolver <probing>
# [type: int, range: [-536870912,536870911], default: -100000]
presolving/probing/priority = -100000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/probing/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
presolving/probing/delay = TRUE

# maximal number of runs, probing participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 1]
presolving/probing/maxruns = 1

# maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)
# [type: int, range: [-1,2147483647], default: -1]
presolving/probing/proprounds = -1

# maximal number of fixings found, until probing is interrupted (0: don't iterrupt)
# [type: int, range: [0,2147483647], default: 50]
presolving/probing/maxfixings = 50

# maximal number of successive probings without fixings, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 2000]
presolving/probing/maxuseless = 3000

# maximal number of successive probings without fixings, bound changes, and implications, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 100]
presolving/probing/maxtotaluseless = 150

# maximal number of probings without fixings, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 0]
presolving/probing/maxsumuseless = 0

# priority of presolver <trivial>
# [type: int, range: [-536870912,536870911], default: 9000000]
presolving/trivial/priority = 9000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/trivial/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/trivial/delay = FALSE
